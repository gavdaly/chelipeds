name: Build, Push & Sign (bootc 43) + ISO (multi-arch)
on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  build-images:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    strategy:
      matrix:
        arch: [amd64]
    env:
      IMAGE: ghcr.io/${{ github.repository_owner }}/chelipeds
      TAG: "43"
    steps:
      - uses: actions/checkout@v4

      - name: Compute date tag
        id: vars
        run: echo "DATE_TAG=$(date +'%Y-%m-%d')" >> $GITHUB_ENV

      - name: Install Podman + QEMU
        run: |
          sudo apt-get update
          sudo apt-get install -y podman qemu-user-static

      - name: Login to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u ${{ github.repository_owner }} --password-stdin

      - name: Build ${{ matrix.arch }}
        run: |
          podman build \
            --platform linux/${{ matrix.arch }} \
            -t $IMAGE:${TAG}-${{ matrix.arch }} \
            -t $IMAGE:${TAG}-${DATE_TAG}-${{ matrix.arch }} \
            .

      - name: Push ${{ matrix.arch }} images
        run: |
          podman push $IMAGE:${TAG}-${{ matrix.arch }}
          podman push $IMAGE:${TAG}-${DATE_TAG}-${{ matrix.arch }}

  create-manifests:
    runs-on: ubuntu-latest
    needs: build-images
    permissions:
      contents: write
      packages: write
      id-token: write
    env:
      IMAGE: ghcr.io/${{ github.repository_owner }}/chelipeds
      TAG: "43"
      ARCH_LIST: "amd64"
    steps:
      - name: Compute date tag
        id: vars
        run: echo "DATE_TAG=$(date +'%Y-%m-%d')" >> $GITHUB_ENV

      - name: Install Podman and Skopeo
        run: |
          sudo apt-get update
          sudo apt-get install -y podman skopeo

      - name: Login to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u ${{ github.repository_owner }} --password-stdin

      - name: Create manifest lists
        run: |
          podman manifest create $IMAGE:${TAG}
          for ARCH in $ARCH_LIST; do
            podman manifest add $IMAGE:${TAG} $IMAGE:${TAG}-$ARCH
          done

          podman manifest create $IMAGE:${TAG}-${DATE_TAG}
          for ARCH in $ARCH_LIST; do
            podman manifest add $IMAGE:${TAG}-${DATE_TAG} $IMAGE:${TAG}-${DATE_TAG}-$ARCH
          done

      - name: Push manifest lists
        run: |
          podman manifest push $IMAGE:${TAG}
          podman manifest push $IMAGE:${TAG}-${DATE_TAG}

      - name: Get manifest digests
        run: |
          DIGEST_TAG=$(skopeo inspect docker://$IMAGE:${TAG} --format "{{.Digest}}")
          DIGEST_DATE_TAG=$(skopeo inspect docker://$IMAGE:${TAG}-${DATE_TAG} --format "{{.Digest}}")
          echo "DIGEST_TAG=$DIGEST_TAG" >> $GITHUB_ENV
          echo "DIGEST_DATE_TAG=$DIGEST_DATE_TAG" >> $GITHUB_ENV
          echo "Manifest digest for $IMAGE:${TAG} -> $DIGEST_TAG"
          echo "Manifest digest for $IMAGE:${TAG}-${DATE_TAG} -> $DIGEST_DATE_TAG"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Cosign sign images (keyless)
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u ${{ github.repository_owner }} --password-stdin
          cosign sign --yes --recursive $IMAGE@$DIGEST_TAG
          cosign sign --yes --recursive $IMAGE@$DIGEST_DATE_TAG

  build-iso:
    runs-on: ${{ matrix.runner }}
    needs: create-manifests
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
    env:
      IMAGE: ghcr.io/${{ github.repository_owner }}/chelipeds
      TAG: "43"
    steps:
      - uses: actions/checkout@v4

      - name: Install Podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Login to GHCR
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u ${{ github.repository_owner }} --password-stdin

      - name: Pull target image
        run: |
          sudo podman pull $IMAGE:${TAG}-${{ matrix.arch }}

      - name: Build bootable ISO (${{ matrix.arch }})
        run: |
          mkdir -p output
          echo "Starting bootc-image-builder with image: $IMAGE:${TAG}-${{ matrix.arch }}"
          echo "Output directory: ${{ github.workspace }}/output"

          # Run bootc-image-builder with verbose output
          sudo podman run --privileged --rm \
            -v /var/lib/containers/storage:/var/lib/containers/storage \
            -v ${{ github.workspace }}/output:/output \
            --security-opt label=disable \
            quay.io/centos-bootc/bootc-image-builder:latest \
            --type iso \
            --rootfs ext4 \
            $IMAGE:${TAG}-${{ matrix.arch }} || {
              echo "bootc-image-builder failed with exit code $?"
              echo "Checking container logs and output directory..."
              ls -la ${{ github.workspace }}/output/
              exit 1
            }

          sudo chown -R $(id -u):$(id -g) ${{ github.workspace }}/output || true
          echo "bootc-image-builder completed successfully"
          echo "Contents of output directory:"
          ls -la ${{ github.workspace }}/output/

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: List output directory contents
        run: |
          echo "Contents of output directory:"
          if [ -d output ]; then
            ls -la output/
            find output -maxdepth 5 -type f -print
          else
            echo "Output directory is empty or doesn't exist"
          fi

      - name: Locate ISO artifacts
        id: locate_iso
        run: |
          if [ ! -d output ]; then
            echo "output/ directory missing"
            exit 1
          fi

          ISO_LIST=$(find output -maxdepth 5 -type f -name '*.iso' -print | sort)
          if [ -z "$ISO_LIST" ]; then
            echo "No ISO file found under output/"
            find output -maxdepth 4 -type f -print || true
            exit 1
          fi

          printf 'Found ISO files:\n%s\n' "$ISO_LIST"
          printf '%s\n' "$ISO_LIST" > output/iso-files.txt
          printf '%s\n' "$ISO_LIST" | sed 's,$,.sig,' > output/iso-sigs.txt
          cat output/iso-files.txt
          cat output/iso-sigs.txt
          echo "iso_list_file=output/iso-files.txt" >> "$GITHUB_OUTPUT"

      - name: Cosign sign ISO
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          ISO_LIST_FILE="${{ steps.locate_iso.outputs.iso_list_file }}"
          if [ -z "$ISO_LIST_FILE" ] || [ ! -f "$ISO_LIST_FILE" ]; then
            echo "ISO list file missing from locate_iso step"
            exit 1
          fi

          echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u ${{ github.repository_owner }} --password-stdin

          while IFS= read -r ISO; do
            [ -z "$ISO" ] && continue
            SIG="${ISO}.sig"
            echo "Signing ISO at $ISO"
            cosign sign-blob --yes "$ISO" --output-signature "$SIG"
            if [ ! -f "$SIG" ]; then
              echo "Expected signature missing at $SIG"
              exit 1
            fi
            ls -la "$(dirname "$SIG")"
            echo "Signed $ISO -> $SIG"
          done < "$ISO_LIST_FILE"

      - name: Upload ISO + signature
        uses: actions/upload-artifact@v4
        with:
          name: chelipeds-iso-43-${{ matrix.arch }}
          path: |
            output/**/*.iso
            output/**/*.iso.sig

      - name: Install rclone
        if: ${{ secrets.R2_ACCESS_KEY_ID != '' && secrets.R2_SECRET_ACCESS_KEY != '' && secrets.R2_ACCOUNT_ID != '' }}
        run: curl https://rclone.org/install.sh | sudo bash
      - name: Upload ISO to Cloudflare R2
        if: ${{ secrets.R2_ACCESS_KEY_ID != '' && secrets.R2_SECRET_ACCESS_KEY != '' && secrets.R2_ACCOUNT_ID != '' }}
        env:
          RCLONE_CONFIG_R2_TYPE: s3
          RCLONE_CONFIG_R2_PROVIDER: Cloudflare
          RCLONE_CONFIG_R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          RCLONE_CONFIG_R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          RCLONE_CONFIG_R2_ENDPOINT: https://${{ secrets.R2_ACCOUNT_ID }}.r2.cloudflarestorage.com
          R2_BUCKET: chelipeds
        run: |
          set -euo pipefail

          ISO_LIST_FILE="${{ steps.locate_iso.outputs.iso_list_file }}"

          if [ -z "${RCLONE_CONFIG_R2_ACCESS_KEY_ID:-}" ] || [ -z "${RCLONE_CONFIG_R2_SECRET_ACCESS_KEY:-}" ]; then
            echo "Required R2 credentials are missing"
            exit 1
          fi

          if [ -z "${ISO_LIST_FILE:-}" ] || [ ! -f "$ISO_LIST_FILE" ]; then
            echo "ISO list file missing; expected path: $ISO_LIST_FILE"
            exit 1
          fi

          uploaded=0
          while IFS= read -r ISO; do
            [ -z "$ISO" ] && continue
            if [ ! -f "$ISO" ]; then
              echo "ISO file '$ISO' not found"
              exit 1
            fi

            SIG="${ISO}.sig"
            if [ ! -f "$SIG" ]; then
              echo "Signature file '$SIG' not found"
              exit 1
            fi

            BASENAME=$(basename "$ISO")
            SIG_BASENAME=$(basename "$SIG")

            echo "Uploading $ISO to r2:${R2_BUCKET}/$BASENAME"
            rclone copyto "$ISO" "r2:${R2_BUCKET}/$BASENAME"

            echo "Uploading $SIG to r2:${R2_BUCKET}/$SIG_BASENAME"
            rclone copyto "$SIG" "r2:${R2_BUCKET}/$SIG_BASENAME"

            uploaded=$((uploaded + 1))
          done < "$ISO_LIST_FILE"

          if [ "$uploaded" -eq 0 ]; then
            echo "No ISO entries processed; aborting"
            exit 1
          fi
